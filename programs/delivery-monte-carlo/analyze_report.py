#!/usr/bin/env python3
"""Analyze simulation report and produce forecast/insight reports."""

import argparse
import csv
import json
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Tuple


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Analyze simulation report and generate forecast reports."
    )
    parser.add_argument(
        "--input-report",
        default="reports/simulation_report.json",
        help="Path to simulation JSON report generated by simulate.py.",
    )
    parser.add_argument(
        "--analysis-config",
        default="analysis_config.json",
        help="Path to analysis tuning config (default: analysis_config.json).",
    )
    parser.add_argument(
        "--output-dir",
        default="reports",
        help="Directory where analysis report files are written.",
    )
    parser.add_argument(
        "--output-name",
        default="analysis_report",
        help="Base filename for output files (default: analysis_report).",
    )
    return parser.parse_args()


def load_json(path: Path) -> Dict[str, Any]:
    try:
        with path.open("r", encoding="utf-8") as fh:
            data = json.load(fh)
    except FileNotFoundError as exc:
        raise ValueError(f"File not found: {path}") from exc
    except json.JSONDecodeError as exc:
        raise ValueError(f"Invalid JSON: {path}: {exc}") from exc

    if not isinstance(data, dict):
        raise ValueError(f"Expected JSON object in: {path}")
    return data


def require_key(data: Dict[str, Any], key: str) -> Any:
    if key not in data:
        raise ValueError(f"Missing key '{key}' in report")
    return data[key]


def safe_div(numerator: float, denominator: float) -> float:
    if denominator == 0:
        return 0.0
    return numerator / denominator


def clamp(value: float, minimum: float, maximum: float) -> float:
    if value < minimum:
        return minimum
    if value > maximum:
        return maximum
    return value


def validate_simulation_report(report: Dict[str, Any]) -> None:
    for key in ["meta", "distributions", "risk", "per_day_expected"]:
        require_key(report, key)


def metric_mean(report: Dict[str, Any], metric: str) -> float:
    dist = report["distributions"]
    if metric not in dist:
        raise ValueError(f"Metric '{metric}' is missing in report.distributions")
    return float(dist[metric]["mean"])


def metric_daily(report: Dict[str, Any], metric: str) -> float:
    per_day = report["per_day_expected"]
    if metric not in per_day:
        raise ValueError(f"Metric '{metric}' is missing in report.per_day_expected")
    return float(per_day[metric])


def evaluate_risk_band(score: float) -> str:
    if score >= 0.67:
        return "HIGH"
    if score >= 0.34:
        return "MEDIUM"
    return "LOW"


def build_kpis(report: Dict[str, Any]) -> Dict[str, float]:
    delivered_orders = metric_mean(report, "delivered_orders")
    total_revenue = metric_mean(report, "total_revenue_usd")
    operating_costs = metric_mean(report, "operating_costs_total_usd")
    total_losses = metric_mean(report, "total_losses_usd")
    net_profit = metric_mean(report, "net_profit_usd")
    gmv_delivered = metric_mean(report, "gmv_delivered_usd")
    processor_fees = metric_mean(report, "processor_fees_usd")
    protection_revenue = metric_mean(report, "protection_revenue_usd")

    delivered_day = metric_daily(report, "delivered_orders")
    refund_day = metric_daily(report, "refund_orders")
    dispute_day = metric_daily(report, "dispute_orders")
    late_day = metric_daily(report, "late_orders")
    support_day = metric_daily(report, "support_tickets")
    protected_day = metric_daily(report, "protected_orders")
    fraud_day = metric_daily(report, "fraud_incidents")

    kpis = {
        "unit_revenue_per_delivered_order_usd": safe_div(total_revenue, delivered_orders),
        "unit_total_cost_per_delivered_order_usd": safe_div(
            operating_costs + total_losses, delivered_orders
        ),
        "unit_net_profit_per_delivered_order_usd": safe_div(net_profit, delivered_orders),
        "net_profit_margin": safe_div(net_profit, total_revenue),
        "platform_take_rate_vs_delivered_gmv": safe_div(total_revenue, gmv_delivered),
        "processor_fee_ratio_vs_revenue": safe_div(processor_fees, total_revenue),
        "protection_revenue_share": safe_div(protection_revenue, total_revenue),
        "refund_rate": safe_div(refund_day, delivered_day),
        "dispute_rate": safe_div(dispute_day, delivered_day),
        "fraud_rate": safe_div(fraud_day, delivered_day),
        "late_delivery_rate": safe_div(late_day, delivered_day),
        "support_tickets_per_100_deliveries": safe_div(support_day, delivered_day) * 100.0,
        "protection_adoption_rate": safe_div(protected_day, delivered_day),
        "loss_probability": float(report["risk"]["loss_probability"]),
        "negative_cash_probability": float(
            report["risk"]["negative_cash_after_reserve_probability"]
        ),
    }
    return kpis


def build_alerts(kpis: Dict[str, float], thresholds: Dict[str, Any]) -> List[str]:
    alerts: List[str] = []

    if kpis["loss_probability"] >= float(thresholds["high_loss_probability"]):
        alerts.append(
            "High risk of net losses. Improve unit economics before scaling volume."
        )

    if kpis["dispute_rate"] >= float(thresholds["high_dispute_rate"]):
        alerts.append(
            "Dispute rate is high. Tighten evidence capture and dispute prevention flow."
        )

    if kpis["refund_rate"] >= float(thresholds["high_refund_rate"]):
        alerts.append(
            "Refund rate is high. Focus on restaurant quality and courier handoff quality."
        )

    high_fraud_threshold = float(thresholds.get("high_fraud_rate", 0.01))
    if kpis["fraud_rate"] >= high_fraud_threshold:
        alerts.append(
            "Fraud pressure is high. Increase controls for new accounts and suspicious velocity patterns."
        )

    if kpis["processor_fee_ratio_vs_revenue"] >= float(
        thresholds["high_processor_fee_ratio"]
    ):
        alerts.append(
            "Processor fees consume too much revenue. Reprice fees or renegotiate acquiring terms."
        )

    if kpis["protection_adoption_rate"] <= float(thresholds["low_protection_adoption"]):
        alerts.append(
            "Protection Plan adoption is low. Increase conversion with clearer value proposition."
        )

    if kpis["unit_net_profit_per_delivered_order_usd"] < 0:
        alerts.append(
            "Unit net profit per delivered order is negative. Current model is not sustainable."
        )

    if not alerts:
        alerts.append("No critical risk alerts triggered by configured thresholds.")

    return alerts


def forecast_scenario(
    report: Dict[str, Any],
    horizon_days: int,
    scenario_name: str,
    scenario_cfg: Dict[str, Any],
) -> Dict[str, Any]:
    daily_revenue = metric_daily(report, "total_revenue_usd")
    daily_costs = metric_daily(report, "operating_costs_total_usd")
    daily_losses = metric_daily(report, "total_losses_usd")
    daily_reserve = metric_daily(report, "reserve_hold_usd")
    daily_delivered = metric_daily(report, "delivered_orders")

    order_growth = float(scenario_cfg["order_growth_rate_per_day"])
    revenue_multiplier = float(scenario_cfg["revenue_multiplier"])
    cost_multiplier = float(scenario_cfg["cost_multiplier"])
    risk_loss_multiplier = float(scenario_cfg["risk_loss_multiplier"])
    reserve_multiplier = float(scenario_cfg["reserve_multiplier"])

    revenue_total = 0.0
    costs_total = 0.0
    losses_total = 0.0
    reserve_total = 0.0
    net_total = 0.0
    cash_total = 0.0
    delivered_total = 0.0

    for day in range(horizon_days):
        volume_factor = (1.0 + order_growth) ** day

        day_revenue = daily_revenue * volume_factor * revenue_multiplier
        day_costs = daily_costs * volume_factor * cost_multiplier
        day_losses = daily_losses * volume_factor * risk_loss_multiplier
        day_reserve = daily_reserve * volume_factor * reserve_multiplier
        day_delivered = daily_delivered * volume_factor

        day_net = day_revenue - day_costs - day_losses
        day_cash = day_net - day_reserve

        revenue_total += day_revenue
        costs_total += day_costs
        losses_total += day_losses
        reserve_total += day_reserve
        net_total += day_net
        cash_total += day_cash
        delivered_total += day_delivered

    return {
        "scenario": scenario_name,
        "horizon_days": horizon_days,
        "projected_delivered_orders": delivered_total,
        "projected_revenue_usd": revenue_total,
        "projected_operating_costs_usd": costs_total,
        "projected_losses_usd": losses_total,
        "projected_net_profit_usd": net_total,
        "projected_reserve_hold_usd": reserve_total,
        "projected_cash_after_reserve_usd": cash_total,
        "projected_net_margin": safe_div(net_total, revenue_total),
        "projected_unit_net_profit_per_order_usd": safe_div(net_total, delivered_total),
    }


def build_forecasts(report: Dict[str, Any], analysis_cfg: Dict[str, Any]) -> List[Dict[str, Any]]:
    horizons = analysis_cfg.get("forecast_days", [30, 90, 180])
    scenarios = analysis_cfg.get("scenarios", {})

    if not isinstance(horizons, list) or not horizons:
        raise ValueError("analysis_config.forecast_days must be a non-empty list")
    if not isinstance(scenarios, dict) or not scenarios:
        raise ValueError("analysis_config.scenarios must be a non-empty object")

    output: List[Dict[str, Any]] = []
    for horizon in horizons:
        horizon_days = int(horizon)
        if horizon_days <= 0:
            raise ValueError("forecast_days values must be > 0")

        for scenario_name, scenario_cfg in scenarios.items():
            output.append(
                forecast_scenario(report, horizon_days, scenario_name, scenario_cfg)
            )

    return output


def build_city_diagnostics(report: Dict[str, Any]) -> List[Dict[str, Any]]:
    city_distributions = report.get("city_distributions", {})
    if not isinstance(city_distributions, dict) or not city_distributions:
        return []

    diagnostics: List[Dict[str, Any]] = []
    for city_name, payload in city_distributions.items():
        kpis = payload.get("kpis", {})
        if not isinstance(kpis, dict):
            continue

        dispute_rate = float(kpis.get("dispute_rate", 0.0))
        fraud_rate = float(kpis.get("fraud_rate", 0.0))
        unit_net = float(kpis.get("unit_net_profit_per_delivered_order_usd", 0.0))
        refund_rate = float(kpis.get("refund_rate", 0.0))
        late_rate = float(kpis.get("late_rate", 0.0))

        risk_score = clamp(
            (0.35 * min(1.0, safe_div(dispute_rate, 0.012)))
            + (0.30 * min(1.0, safe_div(fraud_rate, 0.010)))
            + (0.20 * min(1.0, safe_div(refund_rate, 0.040)))
            + (0.15 * min(1.0, safe_div(max(0.0, -unit_net), 1.50))),
            0.0,
            1.0,
        )

        diagnostics.append(
            {
                "city": city_name,
                "risk_score": risk_score,
                "risk_band": evaluate_risk_band(risk_score),
                "dispute_rate": dispute_rate,
                "fraud_rate": fraud_rate,
                "refund_rate": refund_rate,
                "late_rate": late_rate,
                "unit_net_profit_per_delivered_order_usd": unit_net,
            }
        )

    diagnostics.sort(key=lambda row: row["risk_score"], reverse=True)
    return diagnostics


def build_recommendations(
    kpis: Dict[str, float], alerts: List[str], city_diagnostics: List[Dict[str, Any]]
) -> List[str]:
    recommendations: List[str] = []

    if kpis["unit_net_profit_per_delivered_order_usd"] < 0:
        recommendations.append(
            "Rebalance pricing: increase platform fee, improve Protection conversion, or both."
        )

    if kpis["processor_fee_ratio_vs_revenue"] > 0.4:
        recommendations.append(
            "Reduce acquiring burden: optimize payment mix and review processor fee structure."
        )

    if kpis["dispute_rate"] > 0.008:
        recommendations.append(
            "Invest in proof quality (timestamps, geolocation, delivery confirmation evidence)."
        )

    if kpis["fraud_rate"] > 0.01:
        recommendations.append(
            "Apply tighter onboarding controls for high-risk users and early order velocity checks."
        )

    if kpis["refund_rate"] > 0.04:
        recommendations.append(
            "Focus on top failing restaurants/couriers and enforce quality gates."
        )

    if kpis["protection_adoption_rate"] < 0.2:
        recommendations.append(
            "Increase Protection Plan attach-rate via clearer UX and checkout messaging."
        )

    if city_diagnostics:
        top_city = city_diagnostics[0]
        recommendations.append(
            "Prioritize mitigation in highest-risk city "
            f"'{top_city['city']}' (risk {top_city['risk_band']}, score {top_city['risk_score']:.2f})."
        )

    if not recommendations:
        recommendations.append(
            "Current metrics are balanced. Continue tracking and recalibrate monthly."
        )

    for alert in alerts:
        recommendations.append(f"Alert context: {alert}")

    return recommendations


def pick_best_worst_forecasts(
    forecasts: List[Dict[str, Any]],
) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    if not forecasts:
        empty = {
            "scenario": "n/a",
            "horizon_days": 0,
            "projected_net_profit_usd": 0.0,
            "projected_cash_after_reserve_usd": 0.0,
        }
        return empty, empty

    best = max(forecasts, key=lambda row: row["projected_net_profit_usd"])
    worst = min(forecasts, key=lambda row: row["projected_net_profit_usd"])
    return best, worst


def format_currency(value: float) -> str:
    return f"${value:,.2f}"


def format_pct(value: float) -> str:
    return f"{value * 100:.2f}%"


def format_num(value: float) -> str:
    return f"{value:,.2f}"


def render_markdown(analysis: Dict[str, Any]) -> str:
    meta = analysis["meta"]
    kpis = analysis["kpis"]
    alerts = analysis["alerts"]
    forecasts = analysis["forecasts"]
    recommendations = analysis["recommendations"]
    best = analysis["best_case"]
    worst = analysis["worst_case"]
    city_diagnostics = analysis.get("city_diagnostics", [])

    lines: List[str] = []
    lines.append("# Delivery Analysis Report")
    lines.append("")
    lines.append("## Meta")
    lines.append("")
    lines.append(f"- Source report: {meta['input_report']}")
    lines.append(f"- Analysis config: {meta['analysis_config']}")
    lines.append(f"- Generated at (UTC): {meta['generated_at_utc']}")
    lines.append("")
    lines.append("## KPI Snapshot")
    lines.append("")
    lines.append("| KPI | Value |")
    lines.append("|---|---:|")
    lines.append(
        f"| Unit revenue per delivered order | {format_currency(kpis['unit_revenue_per_delivered_order_usd'])} |"
    )
    lines.append(
        f"| Unit total cost per delivered order | {format_currency(kpis['unit_total_cost_per_delivered_order_usd'])} |"
    )
    lines.append(
        f"| Unit net profit per delivered order | {format_currency(kpis['unit_net_profit_per_delivered_order_usd'])} |"
    )
    lines.append(f"| Net profit margin | {format_pct(kpis['net_profit_margin'])} |")
    lines.append(
        f"| Take rate vs delivered GMV | {format_pct(kpis['platform_take_rate_vs_delivered_gmv'])} |"
    )
    lines.append(
        f"| Processor fee ratio vs revenue | {format_pct(kpis['processor_fee_ratio_vs_revenue'])} |"
    )
    lines.append(f"| Refund rate | {format_pct(kpis['refund_rate'])} |")
    lines.append(f"| Dispute rate | {format_pct(kpis['dispute_rate'])} |")
    lines.append(f"| Fraud rate | {format_pct(kpis['fraud_rate'])} |")
    lines.append(f"| Late delivery rate | {format_pct(kpis['late_delivery_rate'])} |")
    lines.append(
        f"| Support tickets per 100 deliveries | {format_num(kpis['support_tickets_per_100_deliveries'])} |"
    )
    lines.append(f"| Protection adoption rate | {format_pct(kpis['protection_adoption_rate'])} |")
    lines.append(f"| Loss probability | {format_pct(kpis['loss_probability'])} |")
    lines.append(
        f"| Negative cash probability | {format_pct(kpis['negative_cash_probability'])} |"
    )
    lines.append("")

    if city_diagnostics:
        lines.append("## City Risk Ranking")
        lines.append("")
        lines.append(
            "| City | Risk band | Risk score | Dispute rate | Fraud rate | Refund rate | Unit net/order |"
        )
        lines.append("|---|---|---:|---:|---:|---:|---:|")
        for row in city_diagnostics:
            lines.append(
                "| "
                f"{row['city']} | "
                f"{row['risk_band']} | "
                f"{row['risk_score']:.2f} | "
                f"{format_pct(row['dispute_rate'])} | "
                f"{format_pct(row['fraud_rate'])} | "
                f"{format_pct(row['refund_rate'])} | "
                f"{format_currency(row['unit_net_profit_per_delivered_order_usd'])} |"
            )
        lines.append("")

    lines.append("## Alerts")
    lines.append("")
    for alert in alerts:
        lines.append(f"- {alert}")
    lines.append("")
    lines.append("## Forecast Table")
    lines.append("")
    lines.append(
        "| Scenario | Horizon (days) | Net profit | Cash after reserve | Net margin | Unit net/order |"
    )
    lines.append("|---|---:|---:|---:|---:|---:|")
    for row in forecasts:
        lines.append(
            "| "
            f"{row['scenario']} | "
            f"{row['horizon_days']} | "
            f"{format_currency(row['projected_net_profit_usd'])} | "
            f"{format_currency(row['projected_cash_after_reserve_usd'])} | "
            f"{format_pct(row['projected_net_margin'])} | "
            f"{format_currency(row['projected_unit_net_profit_per_order_usd'])} |"
        )
    lines.append("")
    lines.append("## Best and Worst Cases")
    lines.append("")
    lines.append(
        "- Best case: "
        f"{best['scenario']} / {best['horizon_days']} days, "
        f"net profit {format_currency(best['projected_net_profit_usd'])}"
    )
    lines.append(
        "- Worst case: "
        f"{worst['scenario']} / {worst['horizon_days']} days, "
        f"net profit {format_currency(worst['projected_net_profit_usd'])}"
    )
    lines.append("")
    lines.append("## Recommendations")
    lines.append("")
    for item in recommendations:
        lines.append(f"- {item}")

    return "\n".join(lines)


def save_csv(path: Path, analysis: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8", newline="") as fh:
        writer = csv.writer(fh)

        writer.writerow(["section", "key", "value"])
        for key, value in analysis["kpis"].items():
            writer.writerow(["kpi", key, f"{value:.6f}"])

        for idx, alert in enumerate(analysis["alerts"], start=1):
            writer.writerow(["alert", f"alert_{idx}", alert])

        for row in analysis.get("city_diagnostics", []):
            writer.writerow(["city_risk", row["city"], f"{row['risk_score']:.6f}"])
            writer.writerow(["city_risk_band", row["city"], row["risk_band"]])
            writer.writerow(["city_dispute_rate", row["city"], f"{row['dispute_rate']:.6f}"])
            writer.writerow(["city_fraud_rate", row["city"], f"{row['fraud_rate']:.6f}"])
            writer.writerow(["city_refund_rate", row["city"], f"{row['refund_rate']:.6f}"])
            writer.writerow(
                [
                    "city_unit_net_profit_per_order",
                    row["city"],
                    f"{row['unit_net_profit_per_delivered_order_usd']:.6f}",
                ]
            )

        writer.writerow(
            [
                "forecast",
                "scenario",
                "horizon_days",
                "projected_delivered_orders",
                "projected_revenue_usd",
                "projected_operating_costs_usd",
                "projected_losses_usd",
                "projected_net_profit_usd",
                "projected_reserve_hold_usd",
                "projected_cash_after_reserve_usd",
                "projected_net_margin",
                "projected_unit_net_profit_per_order_usd",
            ]
        )
        for row in analysis["forecasts"]:
            writer.writerow(
                [
                    "forecast",
                    row["scenario"],
                    row["horizon_days"],
                    f"{row['projected_delivered_orders']:.6f}",
                    f"{row['projected_revenue_usd']:.6f}",
                    f"{row['projected_operating_costs_usd']:.6f}",
                    f"{row['projected_losses_usd']:.6f}",
                    f"{row['projected_net_profit_usd']:.6f}",
                    f"{row['projected_reserve_hold_usd']:.6f}",
                    f"{row['projected_cash_after_reserve_usd']:.6f}",
                    f"{row['projected_net_margin']:.6f}",
                    f"{row['projected_unit_net_profit_per_order_usd']:.6f}",
                ]
            )


def save_json(path: Path, payload: Dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        json.dump(payload, fh, indent=2)


def save_markdown(path: Path, markdown: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        fh.write(markdown)


def build_analysis(
    report: Dict[str, Any],
    analysis_cfg: Dict[str, Any],
    input_report: Path,
    analysis_config: Path,
) -> Dict[str, Any]:
    kpis = build_kpis(report)

    thresholds = analysis_cfg.get("thresholds", {})
    for required in [
        "high_loss_probability",
        "high_dispute_rate",
        "high_refund_rate",
        "high_processor_fee_ratio",
        "low_protection_adoption",
    ]:
        if required not in thresholds:
            raise ValueError(f"analysis_config.thresholds.{required} is required")

    alerts = build_alerts(kpis, thresholds)
    forecasts = build_forecasts(report, analysis_cfg)
    city_diagnostics = build_city_diagnostics(report)
    recommendations = build_recommendations(kpis, alerts, city_diagnostics)
    best_case, worst_case = pick_best_worst_forecasts(forecasts)

    risk_score = clamp(
        (kpis["loss_probability"] * 0.35)
        + (min(1.0, kpis["dispute_rate"] / max(1e-9, float(thresholds["high_dispute_rate"]))) * 0.20)
        + (min(1.0, kpis["refund_rate"] / max(1e-9, float(thresholds["high_refund_rate"]))) * 0.15)
        + (min(1.0, kpis["fraud_rate"] / max(1e-9, float(thresholds.get("high_fraud_rate", 0.01)))) * 0.15)
        + (min(1.0, max(0.0, -kpis["net_profit_margin"])) * 0.15),
        0.0,
        1.0,
    )

    analysis = {
        "meta": {
            "input_report": str(input_report),
            "analysis_config": str(analysis_config),
            "generated_at_utc": datetime.now(timezone.utc).isoformat(),
            "risk_score": risk_score,
            "risk_band": evaluate_risk_band(risk_score),
            "city_model_enabled": bool(report.get("meta", {}).get("city_model_enabled", False)),
        },
        "kpis": kpis,
        "alerts": alerts,
        "forecasts": forecasts,
        "city_diagnostics": city_diagnostics,
        "best_case": best_case,
        "worst_case": worst_case,
        "recommendations": recommendations,
    }
    return analysis


def print_terminal_summary(analysis: Dict[str, Any]) -> None:
    meta = analysis["meta"]
    kpis = analysis["kpis"]
    best = analysis["best_case"]
    worst = analysis["worst_case"]

    print("Analysis summary")
    print("=" * 40)
    print(f"Risk band: {meta['risk_band']} (score {meta['risk_score']:.3f})")
    print(f"Unit net profit/order: {format_currency(kpis['unit_net_profit_per_delivered_order_usd'])}")
    print(f"Net margin: {format_pct(kpis['net_profit_margin'])}")
    print(f"Loss probability: {format_pct(kpis['loss_probability'])}")
    print(f"Fraud rate: {format_pct(kpis['fraud_rate'])}")
    print(
        "Best forecast: "
        f"{best['scenario']} / {best['horizon_days']} days -> "
        f"{format_currency(best['projected_net_profit_usd'])}"
    )
    print(
        "Worst forecast: "
        f"{worst['scenario']} / {worst['horizon_days']} days -> "
        f"{format_currency(worst['projected_net_profit_usd'])}"
    )

    city_diagnostics = analysis.get("city_diagnostics", [])
    if city_diagnostics:
        top_city = city_diagnostics[0]
        print(
            "Top city risk: "
            f"{top_city['city']} ({top_city['risk_band']}, score {top_city['risk_score']:.2f})"
        )


def main() -> int:
    args = parse_args()

    input_report_path = Path(args.input_report)
    analysis_config_path = Path(args.analysis_config)
    output_dir = Path(args.output_dir)
    output_name = args.output_name

    try:
        report = load_json(input_report_path)
        analysis_cfg = load_json(analysis_config_path)
        validate_simulation_report(report)
    except ValueError as exc:
        print(f"Input error: {exc}", file=sys.stderr)
        return 1

    try:
        analysis = build_analysis(
            report,
            analysis_cfg,
            input_report=input_report_path,
            analysis_config=analysis_config_path,
        )
    except ValueError as exc:
        print(f"Analysis error: {exc}", file=sys.stderr)
        return 1

    print_terminal_summary(analysis)

    json_path = output_dir / f"{output_name}.json"
    md_path = output_dir / f"{output_name}.md"
    csv_path = output_dir / f"{output_name}.csv"

    save_json(json_path, analysis)
    save_markdown(md_path, render_markdown(analysis))
    save_csv(csv_path, analysis)

    print()
    print("Saved analysis files:")
    print(f"- {json_path}")
    print(f"- {md_path}")
    print(f"- {csv_path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
